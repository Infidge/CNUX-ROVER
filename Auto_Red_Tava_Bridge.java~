package org.firstinspires.ftc.teamcode;

import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.util.ElapsedTime;
import com.qualcomm.robotcore.util.Range;

@Autonomous(name="Auto_Red_Tava_Bridge", group="Pushbot")
public class Auto_Red_Tava_Bridge extends LinearOpMode {

    /* Declare OpMode members. */
    HardwareRO183 robot = new HardwareRO183();   // Use a Pushbot's hardware
    private ElapsedTime runtime = new ElapsedTime();

    static final double COUNTS_PER_MOTOR_REV    = 537.6;    // eg: TETRIX Motor Encoder
    static final double COUNTS_PER_CM = (COUNTS_PER_MOTOR_REV / 10 / 3.1415);
    int skystone = 0;
    static final double P_DRIVE_COEFF           = 0.025;
    static final double P_TURN_COEFF            = 0.1;
    static final double HEADING_THRESHOLD       = 1;

    @Override
    public void runOpMode() {

        robot.init(hardwareMap);

        telemetry.addData("Status", "Resetting Encoders");    //
        telemetry.update();


        robot.leftBack.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        robot.leftFront.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        robot.rightFront.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        robot.rightBack.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        robot.lift.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);


        robot.leftBack.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        robot.leftFront.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        robot.rightFront.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        robot.rightBack.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        robot.lift.setMode(DcMotor.RunMode.RUN_USING_ENCODER);

        telemetry.addData("motorfl",    "%2d", robot.leftFront.getCurrentPosition());
        telemetry.addData("motorbl",    "%2d", robot.leftBack.getCurrentPosition());
        telemetry.addData("motorbr",    "%2d", robot.rightBack.getCurrentPosition());
        telemetry.addData("motorfr",    "%2d", robot.rightFront.getCurrentPosition());
        telemetry.addData("motor_lift", "%2d", robot.lift.getCurrentPosition());

        telemetry.addData(">", "Calibrating Gyro");    //
        telemetry.update();

        robot.gyro.calibrate();

        // make sure the gyro is calibrated before continuing
        while (!isStopRequested() && robot.gyro.isCalibrating())  {
            sleep(50);
            idle();
        }

        telemetry.addData(">", "Robot Ready.");
        telemetry.update();

        while (!isStarted()) {
            telemetry.addData(">", "Robot Heading = %d", robot.gyro.getIntegratedZValue());
            telemetry.update();
        }

        robot.gyro.resetZAxisIntegrator();

        telemetry.addData("motor_lift", "%2d",robot.lift.getCurrentPosition());
        telemetry.update();

        waitForStart();
        mergeDreptFata(75,0.5,0.0);
        tava(0,1000);
        gliseazaStanga(39.0, 0.5);
        tava (1,1000);
        gliseazaDreapta(39.0,0.5);
        tava (0,1000);
        mergeInSpate(20.0,0.5,0);
        gyroTurn(0.5,90,2.5);
        mergeDreptFata(20,0.5,90);
        gliseazaDreapta(50,0.5);
        tava(1,1000);
        mergeInSpate(80,0.5,90);
    }


    public void mergeDreptFata(double distance, double speed, double angle) {
        int newLeftBackTarget, newLeftFrontTarget, newRightFrontTarget, newRightBackTarget;
        double  max;
        double  error;
        double  steer;
        double  leftBackSpeed;
        double  leftFrontSpeed;
        double  rightFrontSpeed;
        double  rightBackSpeed;

        if (opModeIsActive()) {

            newLeftBackTarget = robot.leftBack.getCurrentPosition() + (int) (distance * COUNTS_PER_CM);
            newLeftFrontTarget = robot.leftBack.getCurrentPosition() + (int) (distance * COUNTS_PER_CM);
            newRightFrontTarget = robot.rightBack.getCurrentPosition() + (int) (distance * COUNTS_PER_CM);
            newRightBackTarget = robot.rightBack.getCurrentPosition() + (int) (distance * COUNTS_PER_CM);


            robot.leftBack.setTargetPosition(newLeftBackTarget);
            robot.leftFront.setTargetPosition(newLeftFrontTarget);
            robot.rightBack.setTargetPosition(newRightBackTarget);
            robot.rightFront.setTargetPosition(newRightFrontTarget);

            robot.leftBack.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            robot.leftFront.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            robot.rightFront.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            robot.rightBack.setMode(DcMotor.RunMode.RUN_TO_POSITION);


            robot.leftBack.setPower(speed);
            robot.rightBack.setPower(speed);
            robot.leftFront.setPower(speed);
            robot.rightFront.setPower(speed);


            while (opModeIsActive() &&
                    (robot.leftBack.isBusy()  && robot.leftFront.isBusy() && robot.rightFront.isBusy() && robot.rightBack.isBusy())) {

                // adjust relative speed based on heading error.
                error = getError(angle);
                steer = getSteer(error, P_DRIVE_COEFF);

                // if driving in reverse, the motor correction also needs to be reversed
                if (distance < 0)
                    steer *= -1.0;

                leftBackSpeed = speed - steer;
                leftFrontSpeed = speed - steer;
                rightFrontSpeed = speed + steer;
                rightBackSpeed = speed + steer;

                // Normalize speeds if either one exceeds +/- 1.0;
                max = Math.max(Math.max(Math.abs(leftBackSpeed), Math.abs(leftFrontSpeed)), Math.max(Math.abs(rightFrontSpeed), Math.abs(rightBackSpeed)));
                if (max > 1.0)
                {
                    leftBackSpeed   /= max;
                    leftFrontSpeed  /= max;
                    rightFrontSpeed /= max;
                    rightBackSpeed  /= max;
                }

                robot.leftBack.setPower(leftBackSpeed);
                robot.leftFront.setPower(leftFrontSpeed);
                robot.rightFront.setPower(rightFrontSpeed);
                robot.rightBack.setPower(rightBackSpeed);


                telemetry.addData("Target", "Running to %7d :%7d : %7d : %7d", newLeftBackTarget, newLeftFrontTarget, newRightBackTarget, newRightFrontTarget);
                telemetry.addData("Current", "Running at %7d :%7d : %7d : %7d",
                        robot.leftBack.getCurrentPosition(),
                        robot.leftFront.getCurrentPosition(),
                        robot.rightFront.getCurrentPosition(),
                        robot.rightBack.getCurrentPosition());
                telemetry.update();
            }

            robot.leftBack.setPower(0);
            robot.leftFront.setPower(0);
            robot.rightFront.setPower(0);
            robot.rightBack.setPower(0);

            robot.leftBack.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
            robot.leftFront.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
            robot.rightFront.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
            robot.rightBack.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);


            robot.leftBack.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
            robot.leftFront.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
            robot.rightFront.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
            robot.rightBack.setMode(DcMotor.RunMode.RUN_USING_ENCODER);

            sleep(10);
        }
    }

    public void gliseazaDreapta(double distance, double speed) {
        int newLeftBackTarget, newLeftFrontTarget, newRightFrontTarget, newRightBackTarget;

        if (opModeIsActive()) {

            newLeftFrontTarget = robot.leftBack.getCurrentPosition() + (int) (distance * COUNTS_PER_CM);
            newLeftBackTarget = robot.leftBack.getCurrentPosition() - (int) (distance * COUNTS_PER_CM);
            newRightBackTarget = robot.rightBack.getCurrentPosition() - (int) (distance * COUNTS_PER_CM);
            newRightFrontTarget = robot.rightBack.getCurrentPosition() + (int) (distance * COUNTS_PER_CM);


            robot.leftBack.setTargetPosition(newLeftBackTarget);
            robot.leftFront.setTargetPosition(newLeftFrontTarget);
            robot.rightBack.setTargetPosition(newRightBackTarget);
            robot.rightFront.setTargetPosition(newRightFrontTarget);

            robot.leftBack.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            robot.leftFront.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            robot.rightFront.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            robot.rightBack.setMode(DcMotor.RunMode.RUN_TO_POSITION);


            robot.leftFront.setPower(speed);
            robot.leftBack.setPower(-speed);
            robot.rightBack.setPower(-speed);
            robot.rightFront.setPower(speed);


            while (opModeIsActive() &&
                    (robot.leftBack.isBusy() && robot.leftFront.isBusy() && robot.rightFront.isBusy() && robot.rightBack.isBusy())) {


                telemetry.addData("Target", "Running to %7d :%7d : %7d : %7d", newLeftBackTarget, newLeftFrontTarget, newRightBackTarget, newRightFrontTarget);
                telemetry.addData("Current", "Running at %7d :%7d : %7d : %7d",
                        robot.leftBack.getCurrentPosition(),
                        robot.leftFront.getCurrentPosition(),
                        robot.rightFront.getCurrentPosition(),
                        robot.rightBack.getCurrentPosition());
                telemetry.update();
            }

            robot.leftBack.setPower(0);
            robot.leftFront.setPower(0);
            robot.rightFront.setPower(0);
            robot.rightBack.setPower(0);

            robot.leftBack.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
            robot.leftFront.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
            robot.rightFront.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
            robot.rightBack.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);


            robot.leftBack.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
            robot.leftFront.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
            robot.rightFront.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
            robot.rightBack.setMode(DcMotor.RunMode.RUN_USING_ENCODER);

            sleep(10);
        }
    }
    public void gliseazaStanga(double distance, double speed) {
        int newLeftBackTarget, newLeftFrontTarget, newRightFrontTarget, newRightBackTarget;

        if (opModeIsActive()) {

            newLeftFrontTarget = robot.leftBack.getCurrentPosition() - (int) (distance * COUNTS_PER_CM);
            newLeftBackTarget = robot.leftBack.getCurrentPosition() + (int) (distance * COUNTS_PER_CM);
            newRightBackTarget = robot.rightBack.getCurrentPosition() + (int) (distance * COUNTS_PER_CM);
            newRightFrontTarget = robot.rightBack.getCurrentPosition() - (int) (distance * COUNTS_PER_CM);


            robot.leftBack.setTargetPosition(newLeftBackTarget);
            robot.leftFront.setTargetPosition(newLeftFrontTarget);
            robot.rightBack.setTargetPosition(newRightBackTarget);
            robot.rightFront.setTargetPosition(newRightFrontTarget);

            robot.leftBack.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            robot.leftFront.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            robot.rightFront.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            robot.rightBack.setMode(DcMotor.RunMode.RUN_TO_POSITION);

            robot.rightBack.setPower(-speed);
            robot.rightFront.setPower(speed);
            robot.leftFront.setPower(-speed);
            robot.leftBack.setPower(speed);



            while (opModeIsActive() &&
                    (robot.leftBack.isBusy() && robot.leftFront.isBusy() && robot.rightFront.isBusy() && robot.rightBack.isBusy())) {


                telemetry.addData("Target", "Running to %7d :%7d : %7d : %7d", newLeftBackTarget, newLeftFrontTarget, newRightBackTarget, newRightFrontTarget);
                telemetry.addData("Current", "Running at %7d :%7d : %7d : %7d",
                        robot.leftBack.getCurrentPosition(),
                        robot.leftFront.getCurrentPosition(),
                        robot.rightFront.getCurrentPosition(),
                        robot.rightBack.getCurrentPosition());
                telemetry.update();
            }

            robot.leftBack.setPower(0);
            robot.leftFront.setPower(0);
            robot.rightFront.setPower(0);
            robot.rightBack.setPower(0);

            robot.leftBack.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
            robot.leftFront.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
            robot.rightFront.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
            robot.rightBack.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);


            robot.leftBack.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
            robot.leftFront.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
            robot.rightFront.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
            robot.rightBack.setMode(DcMotor.RunMode.RUN_USING_ENCODER);

            sleep(10);
        }
    }

    public void mergeInSpate(double distance, double speed, double angle) {
        int newLeftBackTarget, newLeftFrontTarget, newRightFrontTarget, newRightBackTarget;
        double  max;
        double  error;
        double  steer;
        double  leftBackSpeed;
        double  leftFrontSpeed;
        double  rightFrontSpeed;
        double  rightBackSpeed;

        if (opModeIsActive()) {

            newLeftFrontTarget = robot.leftBack.getCurrentPosition() - (int) (distance * COUNTS_PER_CM);
            newLeftBackTarget = robot.leftBack.getCurrentPosition() - (int) (distance * COUNTS_PER_CM);
            newRightBackTarget = robot.rightBack.getCurrentPosition() - (int) (distance * COUNTS_PER_CM);
            newRightFrontTarget = robot.rightBack.getCurrentPosition() - (int) (distance * COUNTS_PER_CM);


            robot.leftBack.setTargetPosition(newLeftBackTarget);
            robot.leftFront.setTargetPosition(newLeftFrontTarget);
            robot.rightBack.setTargetPosition(newRightBackTarget);
            robot.rightFront.setTargetPosition(newRightFrontTarget);

            robot.leftBack.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            robot.leftFront.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            robot.rightFront.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            robot.rightBack.setMode(DcMotor.RunMode.RUN_TO_POSITION);

            robot.leftFront.setPower(-speed);
            robot.leftBack.setPower(-speed);
            robot.rightBack.setPower(-speed);
            robot.rightFront.setPower(-speed);


            while (opModeIsActive() &&
                    (robot.leftBack.isBusy() && robot.leftFront.isBusy() && robot.rightFront.isBusy() && robot.rightBack.isBusy())) {
                // adjust relative speed based on heading error.
                error = getError(angle);
                steer = getSteer(error, P_DRIVE_COEFF);

                // if driving in reverse, the motor correction also needs to be reversed
                if (distance < 0)
                    steer *= -1.0;

                leftBackSpeed = speed + steer;
                leftFrontSpeed = speed + steer;
                rightFrontSpeed = speed - steer;
                rightBackSpeed = speed - steer;

                // Normalize speeds if either one exceeds +/- 1.0;
                max = Math.max(Math.max(Math.abs(leftBackSpeed), Math.abs(leftFrontSpeed)), Math.max(Math.abs(rightFrontSpeed), Math.abs(rightBackSpeed)));
                if (max > 1.0)
                {
                    leftBackSpeed   /= max;
                    leftFrontSpeed  /= max;
                    rightFrontSpeed /= max;
                    rightBackSpeed  /= max;
                }

                robot.leftBack.setPower(-leftBackSpeed);
                robot.leftFront.setPower(-leftFrontSpeed);
                robot.rightFront.setPower(-rightFrontSpeed);
                robot.rightBack.setPower(-rightBackSpeed);


                telemetry.addData("Target", "Running to %7d :%7d : %7d : %7d", newLeftBackTarget, newLeftFrontTarget, newRightBackTarget, newRightFrontTarget);
                telemetry.addData("Current", "Running at %7d :%7d : %7d : %7d",
                        robot.leftBack.getCurrentPosition(),
                        robot.leftFront.getCurrentPosition(),
                        robot.rightFront.getCurrentPosition(),
                        robot.rightBack.getCurrentPosition());
                telemetry.update();
            }

            robot.leftBack.setPower(0);
            robot.leftFront.setPower(0);
            robot.rightFront.setPower(0);
            robot.rightBack.setPower(0);

            robot.leftBack.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
            robot.leftFront.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
            robot.rightFront.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
            robot.rightBack.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);


            robot.leftBack.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
            robot.leftFront.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
            robot.rightFront.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
            robot.rightBack.setMode(DcMotor.RunMode.RUN_USING_ENCODER);

            sleep(10);
        }
    }

    public void intoarceDreapta(double distance, double speed, double angle) {
        int newLeftBackTarget, newLeftFrontTarget, newRightFrontTarget, newRightBackTarget;
        double  max;
        double  error;
        double  steer;
        double  leftBackSpeed;
        double  leftFrontSpeed;
        double  rightFrontSpeed;
        double  rightBackSpeed;

        if (opModeIsActive()) {

            newLeftFrontTarget = robot.leftBack.getCurrentPosition() + (int) (distance * COUNTS_PER_CM);
            newLeftBackTarget = robot.leftBack.getCurrentPosition() + (int) (distance * COUNTS_PER_CM);
            newRightBackTarget = robot.rightBack.getCurrentPosition() - (int) (distance * COUNTS_PER_CM);
            newRightFrontTarget = robot.rightBack.getCurrentPosition() - (int) (distance * COUNTS_PER_CM);


            robot.leftBack.setTargetPosition(newLeftBackTarget);
            robot.leftFront.setTargetPosition(newLeftFrontTarget);
            robot.rightBack.setTargetPosition(newRightBackTarget);
            robot.rightFront.setTargetPosition(newRightFrontTarget);

            robot.leftBack.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            robot.leftFront.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            robot.rightFront.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            robot.rightBack.setMode(DcMotor.RunMode.RUN_TO_POSITION);

            robot.leftFront.setPower(speed);
            robot.leftBack.setPower(speed);
            robot.rightBack.setPower(-speed);
            robot.rightFront.setPower(-speed);


            while (opModeIsActive() &&
                    (robot.leftBack.isBusy() && robot.leftFront.isBusy() && robot.rightFront.isBusy() && robot.rightBack.isBusy())) {

                // adjust relative speed based on heading error.
                error = getError(angle);
                steer = getSteer(error, P_DRIVE_COEFF);

                // if driving in reverse, the motor correction also needs to be reversed
                if (distance < 0)
                    steer *= -1.0;

                leftBackSpeed = speed - steer;
                leftFrontSpeed = speed - steer;
                rightFrontSpeed = speed + steer;
                rightBackSpeed = speed + steer;

                // Normalize speeds if either one exceeds +/- 1.0;
                max = Math.max(Math.max(Math.abs(leftBackSpeed), Math.abs(leftFrontSpeed)), Math.max(Math.abs(rightFrontSpeed), Math.abs(rightBackSpeed)));
                if (max > 1.0)
                {
                    leftBackSpeed   /= max;
                    leftFrontSpeed  /= max;
                    rightFrontSpeed /= max;
                    rightBackSpeed  /= max;
                }

                robot.leftBack.setPower(leftBackSpeed);
                robot.leftFront.setPower(leftFrontSpeed);
                robot.rightFront.setPower(rightFrontSpeed);
                robot.rightBack.setPower(rightBackSpeed);


                telemetry.addData("Target", "Running to %7d :%7d : %7d : %7d", newLeftBackTarget, newLeftFrontTarget, newRightBackTarget, newRightFrontTarget);
                telemetry.addData("Current", "Running at %7d :%7d : %7d : %7d",
                        robot.leftBack.getCurrentPosition(),
                        robot.leftFront.getCurrentPosition(),
                        robot.rightFront.getCurrentPosition(),
                        robot.rightBack.getCurrentPosition());
                telemetry.update();
            }

            robot.leftBack.setPower(0);
            robot.leftFront.setPower(0);
            robot.rightFront.setPower(0);
            robot.rightBack.setPower(0);

            robot.leftBack.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
            robot.leftFront.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
            robot.rightFront.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
            robot.rightBack.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);


            robot.leftBack.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
            robot.leftFront.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
            robot.rightFront.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
            robot.rightBack.setMode(DcMotor.RunMode.RUN_USING_ENCODER);

            sleep(10);
        }
    }

    public void intoarceStanga(double distance, double speed, double angle) {
        int newLeftBackTarget, newLeftFrontTarget, newRightFrontTarget, newRightBackTarget;
        double  max;
        double  error;
        double  steer;
        double  leftBackSpeed;
        double  leftFrontSpeed;
        double  rightFrontSpeed;
        double  rightBackSpeed;

        if (opModeIsActive()) {

            newLeftFrontTarget = robot.leftBack.getCurrentPosition() - (int) (distance * COUNTS_PER_CM);
            newLeftBackTarget = robot.leftBack.getCurrentPosition() - (int) (distance * COUNTS_PER_CM);
            newRightBackTarget = robot.rightBack.getCurrentPosition() + (int) (distance * COUNTS_PER_CM);
            newRightFrontTarget = robot.rightBack.getCurrentPosition() + (int) (distance * COUNTS_PER_CM);


            robot.leftBack.setTargetPosition(newLeftBackTarget);
            robot.leftFront.setTargetPosition(newLeftFrontTarget);
            robot.rightBack.setTargetPosition(newRightBackTarget);
            robot.rightFront.setTargetPosition(newRightFrontTarget);

            robot.leftBack.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            robot.leftFront.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            robot.rightFront.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            robot.rightBack.setMode(DcMotor.RunMode.RUN_TO_POSITION);

            robot.leftFront.setPower(speed);
            robot.leftBack.setPower(-speed);
            robot.rightBack.setPower(speed);
            robot.rightFront.setPower(speed);


            while (opModeIsActive() &&
                    (robot.leftBack.isBusy() && robot.leftFront.isBusy() && robot.rightFront.isBusy() && robot.rightBack.isBusy())) {

                // adjust relative speed based on heading error.
                error = getError(angle);
                steer = getSteer(error, P_DRIVE_COEFF);

                // if driving in reverse, the motor correction also needs to be reversed
                if (distance < 0)
                    steer *= -1.0;

                leftBackSpeed = speed - steer;
                leftFrontSpeed = speed - steer;
                rightFrontSpeed = speed + steer;
                rightBackSpeed = speed + steer;

                // Normalize speeds if either one exceeds +/- 1.0;
                max = Math.max(Math.max(Math.abs(leftBackSpeed), Math.abs(leftFrontSpeed)), Math.max(Math.abs(rightFrontSpeed), Math.abs(rightBackSpeed)));
                if (max > 1.0)
                {
                    leftBackSpeed   /= max;
                    leftFrontSpeed  /= max;
                    rightFrontSpeed /= max;
                    rightBackSpeed  /= max;
                }

                robot.leftBack.setPower(leftBackSpeed);
                robot.leftFront.setPower(leftFrontSpeed);
                robot.rightFront.setPower(rightFrontSpeed);
                robot.rightBack.setPower(rightBackSpeed);


                telemetry.addData("Target", "Running to %7d :%7d : %7d : %7d", newLeftBackTarget, newLeftFrontTarget, newRightBackTarget, newRightFrontTarget);
                telemetry.addData("Current", "Running at %7d :%7d : %7d : %7d",
                        robot.leftBack.getCurrentPosition(),
                        robot.leftFront.getCurrentPosition(),
                        robot.rightFront.getCurrentPosition(),
                        robot.rightBack.getCurrentPosition());
                telemetry.update();
            }

            robot.leftBack.setPower(0);
            robot.leftFront.setPower(0);
            robot.rightFront.setPower(0);
            robot.rightBack.setPower(0);

            robot.leftBack.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
            robot.leftFront.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
            robot.rightFront.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
            robot.rightBack.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);


            robot.leftBack.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
            robot.leftFront.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
            robot.rightFront.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
            robot.rightBack.setMode(DcMotor.RunMode.RUN_USING_ENCODER);

            sleep(10);
        }
    }

    public void tava (double position, long timeout) {
        if (opModeIsActive()){
            robot.tava1.setPosition(position);
            robot.tava2.setPosition(1-position);
            sleep(timeout);
        }

    }

    public void piesa (double slider, double claw){
        if (opModeIsActive()){
            robot.slider.setPosition(slider);
            sleep(10);
            robot.claw.setPosition(claw);
            sleep(10);
        }

    }
    public void lift (int position){

        if(opModeIsActive()){
            robot.lift.setTargetPosition(position);
            robot.lift.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            robot.lift.setPower(1.0);
            while (opModeIsActive() && robot.lift.isBusy()){
                telemetry.addData("Target", "%2d", robot.lift.getTargetPosition());
                telemetry.addData("Current", "%2d", robot.lift.getCurrentPosition());
            }
            robot.lift.setPower(0.0);
            robot.lift.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
            robot.lift.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        }
    }
    public double getError(double targetAngle) {

        double robotError;

        // calculate error in -179 to +180 range  (
        robotError = targetAngle - robot.gyro.getIntegratedZValue();
        while (robotError > 180)  robotError -= 360;
        while (robotError <= -180) robotError += 360;
        return robotError;
    }

    public double getSteer(double error, double PCoeff) {
        return Range.clip(error * PCoeff, -1, 1);
    }

    public void gyroTurn (  double speed, double angle,double timeout) {
        runtime.reset();
        while (opModeIsActive() && !onHeading(speed, angle, P_TURN_COEFF) && runtime.seconds()< timeout) {
            // Update telemetry & Allow time for other processes to run.
            telemetry.update();
        }
    }

    boolean onHeading(double speed, double angle, double PCoeff) {
        double   error ;
        double   steer ;
        boolean  onTarget = false ;
        double leftBackSpeed;
        double leftFrontSpeed;
        double rightFrontSpeed;
        double rightBackSpeed;

        // determine turn power based on +/- error
        error = getError(angle);

        if (Math.abs(error) <= HEADING_THRESHOLD) {
            steer = 0.0;
            leftBackSpeed  = 0.0;
            leftFrontSpeed = 0.0;
            rightFrontSpeed = 0.0;
            rightBackSpeed = 0.0;
            onTarget = true;
        }
        else {
            steer = getSteer(error, PCoeff);
            rightFrontSpeed  = speed * steer;
            rightBackSpeed   = speed * steer;
            leftBackSpeed   = -rightBackSpeed;
            leftFrontSpeed  = -rightFrontSpeed;
        }
        // Send desired speeds to motors.
        robot.leftBack.setPower(leftBackSpeed);
        robot.leftFront.setPower(leftFrontSpeed);
        robot.rightFront.setPower(rightFrontSpeed);
        robot.rightBack.setPower(rightBackSpeed);

        // Display it for the driver.
        telemetry.addData("Target", "%5.2f", angle);
        telemetry.addData("Err/St", "%5.2f/%5.2f", error, steer);
        telemetry.addData("Speed.", "%5.2f:%5.2f:%5.2f:%5.2f", leftBackSpeed, leftFrontSpeed,rightFrontSpeed, rightBackSpeed);

        return onTarget;
    }
    public void gyroHold( double speed, double angle, double holdTime) {

        ElapsedTime holdTimer = new ElapsedTime();

        // keep looping while we have time remaining.
        holdTimer.reset();
        while (opModeIsActive() && (holdTimer.time() < holdTime)) {
            // Update telemetry & Allow time for other processes to run.
            onHeading(speed, angle, P_TURN_COEFF);
            telemetry.update();
        }

        // Stop all motion;
        robot.leftBack.setPower(0);
        robot.leftFront.setPower(0);
        robot.rightFront.setPower(0);
        robot.rightBack.setPower(0);
    }
}